<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Website Editor Dashboard</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23667eea' width='100' height='100' rx='20'/%3E%3Cpath fill='%23fff' d='M30 25h25v8H30z'/%3E%3Cpath fill='%23fff' opacity='0.7' d='M30 38h35v5H30zM30 48h30v5H30zM30 58h35v5H30z'/%3E%3Cpath fill='%23fff' d='M45 70h25v8H45z'/%3E%3Cpath fill='%23fff' opacity='0.7' d='M45 53h30v5H45zM45 63h25v5H45z'/%3E%3C/svg%3E">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            color: #2d3748;
            font-size: 1.8rem;
            font-weight: 600;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            grid-template-columns: 200px 1fr;
            gap: 1rem;
            height: calc(100vh - 100px);
        }

        @media (min-width: 1900px) {
            .container {
                max-width: calc(100% - 100px);
            }
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            overflow-x: hidden;
            min-width: 0;
        }

        .main-content {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 0.5rem;
        }

        .controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .editor-area {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            box-shadow: 0 4px 25px rgba(0, 0, 0, 0.1);
            overflow: visible;
            display: grid;
            grid-template-columns: 3fr 1fr;
            position: relative;
        }

        .preview-panel {
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            /* overflow: auto; */
        }

        .preview-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: white;
            transition: opacity 0.3s ease;
        }

        .preview-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
            z-index: 10;
        }

        .preview-panel {
            position: relative;
        }

        .editing-panel {
            padding: 1rem;
            overflow-y: auto;
            background: white;
            transition: transform 0.3s ease;
            position: relative;
        }

        .editing-panel.hidden {
            display: none;
        }

        .sidebar-toggle {
            position: absolute;
            top: 110px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            /* z-index: 1000; */
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        /* Responsive positioning for different screen sizes */
        @media (min-width: 1920px) {
            .sidebar-toggle {
                right: calc((100vw - 1800px) / 2 + 15px);
            }
        }

        @media (max-width: 1200px) {
            .sidebar-toggle {
                right: 10px;
                top: 100px;
            }
        }

        .sidebar-toggle:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .sidebar-toggle:active {
            transform: translateY(0);
        }

        .editor-area.sidebar-hidden {
            grid-template-columns: 1fr;
        }

        .section {
            margin-bottom: 2rem;
        }

        .section h3 {
            color: #2d3748;
            margin-bottom: 1rem;
            font-size: 1.1rem;
            font-weight: 600;
            border-bottom: 2px solid #667eea;
            padding-bottom: 0.5rem;
        }

        .site-list {
            list-style: none;
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
        }

        .site-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #f8f9fa;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            overflow-wrap: break-word;
            word-wrap: break-word;
            word-break: break-word;
            hyphens: auto;
            border: 1px solid #e2e8f0;
        }

        .site-item:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .site-item.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .site-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .site-url {
            font-size: 0.8rem;
            opacity: 0.7;
            word-break: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }
        
        .site-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 8px;
        }
        
        .delete-btn {
            background: none;
            border: none;
            color: #e53e3e;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s ease;
        }
        
        .delete-btn:hover {
            background-color: rgba(229, 62, 62, 0.1);
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5a67d8;
            transform: translateY(-1px);
        }

        .btn-success {
            background: #48bb78;
            color: white;
        }

        .btn-success:hover {
            background: #38a169;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .element-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .element-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }

        .element-tag {
            font-size: 0.7rem;
            background: #667eea;
            color: white;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            display: inline-block;
        }

        .element-text {
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            word-break: break-word;
        }

        .input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .form-input {
            width: 100%;
            flex: 1;
            padding: 0.4rem 0.6rem;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 0.9rem;
        }

        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .color-input {
            width: 40px;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .loading {
            text-align: center;
            padding: 2rem;
            color: #666;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #48bb78;
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
            max-width: 300px;
            width: auto;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            background: #e53e3e;
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            visibility: hidden;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .modal-overlay.show {
            visibility: visible;
            opacity: 1;
        }
        
        .modal-content {
            background: white;
            border-radius: 8px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        
        .modal-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #2d3748;
        }
        
        .modal-text {
            margin-bottom: 1.5rem;
            color: #4a5568;
        }
        
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 0.5rem;
        }
        
        .btn-danger {
            background: #e53e3e;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c53030;
        }

        /* Element selection styles */
        .element-selection-active {
            cursor: crosshair !important;
        }

        .element-selected {
            outline: 3px solid #667eea !important;
            outline-offset: 2px !important;
            background-color: rgba(102, 126, 234, 0.1) !important;
            position: relative !important;
        }

        .element-hover {
            outline: 2px dashed #667eea !important;
            outline-offset: 1px !important;
        }

        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }

        .editing-group {
            border-left: 3px solid #667eea;
            padding-left: 1rem;
        }

        /* Selection overlay styles */
        .selection-overlay {
            position: fixed;
            pointer-events: none;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.1);
            z-index: 10000;
            transition: all 0.1s ease;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            
            .editor-area {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <a href="/" class="btn btn-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="24" fill="currentColor" viewBox="0 0 16 16">
                  <path d="M8.354 1.146a.5.5 0 0 0-.708 0l-6 6A.5.5 0 0 0 1.5 7.5v7a.5.5 0 0 0 .5.5h4.5a.5.5 0 0 0 .5-.5v-4h2v4a.5.5 0 0 0 .5.5H14a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.146-.354L13 5.793V2.5a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1.293L8.354 1.146zM2.5 14V7.707l5.5-5.5 5.5 5.5V14H10v-4a.5.5 0 0 0-.5-.5h-3a.5.5 0 0 0-.5.5v4H2.5z"/>
                </svg>
              </a>
            <h1>üé® Website Editor Dashboard</h1>
            
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>üìÅ Cloned Sites</h3>
                <ul class="site-list" id="siteList">
                    <li class="loading">Loading sites...</li>
                </ul>
            </div>
        </div>

        <div class="main-content">
            <div class="controls">
                <!-- <button class="btn btn-secondary" id="previewBtn" disabled>
                    üëÅÔ∏è Open Preview
                </button> -->
                <button class="btn btn-secondary" id="deployBtn" disabled>
                    üëÅÔ∏è Open Preview
                </button>
                <!-- <label class="auto-deploy-label">
                    <input type="checkbox" id="autoDeployCheckbox">
                    Auto-deploy on save
                </label> -->
                <span id="unsavedChanges" style="color: #e53e3e; font-weight: 500; display: none;">
                    ‚Ä¢ Unsaved changes
                </span>
            </div>

            <div class="editor-area">
                <div class="preview-panel">
                    <div id="previewLoading" class="preview-loading" style="display: none;">
                        üîÑ Loading preview...
                    </div>
                    <iframe id="previewFrame" class="preview-iframe" src="about:blank"></iframe>
                </div>

                <div class="editing-panel" id="editingPanel">
                    <div id="noSiteSelected" class="loading">
                        Select a site from the sidebar to start editing
                    </div>

                    <div id="editingContent" style="display: none;">
                        <!-- Refresh Button -->
                        <div class="section">
                            <div style="text-align: center; margin-bottom: 1rem; display: flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;">
                                <button id="refreshBtn" class="btn btn-secondary" title="Refresh Editor">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z"/>
                                        <path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z"/>
                                    </svg>
                                    Refresh
                                </button>
                            
                            </div>
                        </div>

                        <!-- Website Font Controls -->
                        <div class="section">
                            <h3>üî§ Website Font</h3>
                            <!-- <div style="display: flex; gap: 0.5rem; align-items: center; margin-bottom: 1rem;"> -->
                                <select id="fontSelector" class="form-input" style="flex: 1;">
                                    <option value="" style="width: 100%; font-size: 0.9rem;">Select Font</option>
                                    <option value="Arial, sans-serif">Arial</option>
                                    <option value="Helvetica, sans-serif">Helvetica</option>
                                    <option value="'Times New Roman', serif">Times New Roman</option>
                                    <option value="Georgia, serif">Georgia</option>
                                    <option value="'Courier New', monospace">Courier New</option>
                                    <option value="Verdana, sans-serif">Verdana</option>
                                    <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                                    <option value="'Lucida Console', monospace">Lucida Console</option>
                                    <option value="'Palatino Linotype', serif">Palatino</option>
                                    <option value="Tahoma, sans-serif">Tahoma</option>
                                    <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                                    <option value="Impact, sans-serif">Impact</option>
                                    <option value="'Lucida Sans Unicode', sans-serif">Lucida Sans</option>
                                    <option value="'Book Antiqua', serif">Book Antiqua</option>
                                    <option value="'Century Gothic', sans-serif">Century Gothic</option>
                                </select>
                                <button id="applyFont" class="btn btn-primary" style="width: 100%; font-size: 0.9rem; margin-top: 0.5rem;">Apply Font</button>
                            <!-- </div> -->
                        </div>

                        <!-- Highlight Images Section -->
                        <div class="section">
                            <h3>üñºÔ∏è Highlight Images</h3>
                            <div style="margin-bottom: 1rem;">
                                <button id="highlightImagesBtn" class="btn btn-primary" style="width: 100%; font-size: 0.9rem;" title="Highlight All Images">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                                        <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>
                                    </svg>
                                    Show All Images
                                </button>
                            </div>
                        </div>

                        <!-- Selection Mode Toggle -->
                        <div class="section">
                            <h3>üéØ Element Selection</h3>
                            <div style="margin-bottom: 1rem;">
                                <button id="toggleSelectionMode" class="btn btn-primary" style="width: 100%; font-size: 0.9rem;">
                                    Enable Click-to-Select
                                </button>
                            </div>
                            <div id="selectionInstructions" style="background: #f0f8ff; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; display: none;">
                                <p style="margin: 0; color: #1a365d; font-size: 0.9rem;">
                                    üñ±Ô∏è Click on any element in the preview to select and edit it
                                </p>
                            </div>
                        </div>

                        <!-- Selected Element Editor -->
                        <div id="selectedElementEditor" style="display: none;">
                            <div class="section">
                                <!-- <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;"> -->
                                    <h3>‚úèÔ∏è Selected Element</h3>
                                    <button id="clearSelection" class="btn btn-secondary btn-sm" style="width: 100%; font-size: 0.9rem; margin-bottom: 1rem;">Clear Selection</button>
                                <!-- </div> -->
                                
                                <!-- <div id="elementInfo" style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;"> -->
                                <div id="elementInfo" style="display: none;">
                                    <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                        <span id="elementTag" class="element-tag"></span>
                                        <span id="elementSelector" style="font-size: 0.8rem; color: #666;"></span>
                                    </div>
                                    <div id="elementContent" style="font-size: 0.9rem; color: #333;"></div>
                                </div>

                                <!-- Image-specific Controls -->
                                <div id="imageControls" class="editing-group" style="margin-bottom: 1.5rem; display: none;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">üñºÔ∏è Image Actions</label>
                                    <!-- <div style="display: flex; gap: 0.5rem;"> -->
                                        <button id="deleteImage" class="btn btn-danger" style="width: 100%; font-size: 0.9rem;">üóëÔ∏è Delete Image</button>
                                        <button id="replaceImage" class="btn btn-primary" style="width: 100%; font-size: 0.9rem; margin-top: 0.5rem;">üîÑ Replace Image</button>
                                    <!-- </div> -->
                                    <input type="file" id="imageFileInput" accept="image/*" style="display: none;">
                                </div>

                                <!-- Text Content Editor -->
                                <div id="textContentEditor" class="editing-group" style="margin-bottom: 1.5rem;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">üìù Text Content</label>
                                    <!-- <div style="display: flex; gap: 0.5rem;"> -->
                                        <textarea id="elementTextEditor" class="form-input" rows="3" style="resize: vertical; width: 100%;"></textarea>
                                        <button id="updateElementText" class="btn btn-success" style="width: 100%; font-size: 0.9rem;">Update</button>
                                    <!-- </div> -->
                                </div>


                                <!-- Quick Color Controls - Only shown for elements with text content -->
                                <div id="colorControls" class="editing-group" style="display: none;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 0.5rem;">üé® Quick Colors</label>
                                    <!-- <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;"> -->
                                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                                            <input type="color" id="textColorPicker" class="color-input">
                                            <button id="applyTextColor" class="btn btn-primary btn-sm" style="width: 100%; font-size: 0.9rem;">Apply Colour</button>
                                        </div>
                                        <div style="display: flex; gap: 0.5rem; align-items: center;">
                                            <input type="color" id="bgColorPicker" class="color-input">
                                            <button id="applyBgColor" class="btn btn-primary btn-sm" style="width: 100%; font-size: 0.9rem;">Apply Background</button>
                                        </div>
                                    <!-- </div> -->
                                </div>

                            </div>
                        </div>

                            </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sidebar Toggle Button - Always Visible -->
    <button class="sidebar-toggle" id="sidebarToggle" title="Hide Sidebar">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/>
        </svg>
    </button>

    <div id="toast" class="toast"></div>
    
    <!-- Delete Confirmation Modal -->
    <div id="deleteModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-title">Delete Site</div>
            <div class="modal-text">
                Are you sure you want to delete this site? This action cannot be undone.
                <div id="deleteSiteName" style="font-weight: bold; margin-top: 8px;"></div>
            </div>
            <div class="modal-actions">
                <button id="cancelDeleteBtn" class="btn btn-secondary">Cancel</button>
                <button id="confirmDeleteBtn" class="btn btn-danger">Delete</button>
            </div>
        </div>
    </div>

    <script>
        let currentSiteId = null;
        let selectionMode = false;
        let selectedElement = null;
        let elementSelector = null;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async () => {
            await loadSites();
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('deployBtn').addEventListener('click', deploySite);
            document.getElementById('refreshBtn').addEventListener('click', refreshEditor);
            document.getElementById('highlightImagesBtn').addEventListener('click', highlightAllImages);
            document.getElementById('sidebarToggle').addEventListener('click', toggleSidebar);
            
            // Delete modal event listeners
            document.getElementById('cancelDeleteBtn').addEventListener('click', hideDeleteModal);
            document.getElementById('confirmDeleteBtn').addEventListener('click', confirmDeleteSite);
            
            // Element selection event listeners
            document.getElementById('toggleSelectionMode').addEventListener('click', toggleSelectionMode);
            document.getElementById('clearSelection').addEventListener('click', clearElementSelection);
            
            // Element editing event listeners
            document.getElementById('updateElementText').addEventListener('click', updateSelectedElementText);
            document.getElementById('applyTextColor').addEventListener('click', applyTextColor);
            document.getElementById('applyBgColor').addEventListener('click', applyBgColor);
            
            // Image-specific event listeners
            document.getElementById('deleteImage').addEventListener('click', deleteSelectedImage);
            document.getElementById('replaceImage').addEventListener('click', () => {
                document.getElementById('imageFileInput').click();
            });
            document.getElementById('imageFileInput').addEventListener('change', replaceSelectedImage);
            
            // Font style event listener
            document.getElementById('applyFont').addEventListener('click', applyWebsiteFont);
        }
        
        function deploySite() {
            if (!currentSiteId) return;
            window.open(`/${currentSiteId}`, '_blank');
        }
        
        function refreshEditor() {
            window.location.reload();
        }

        function toggleSidebar() {
            const editingPanel = document.getElementById('editingPanel');
            const editorArea = document.querySelector('.editor-area');
            const toggleButton = document.getElementById('sidebarToggle');
            const toggleIcon = toggleButton.querySelector('svg path');
            
            if (editingPanel.classList.contains('hidden')) {
                // Show sidebar (arrow points left - sidebar comes from right)
                editingPanel.classList.remove('hidden');
                editorArea.classList.remove('sidebar-hidden');
                toggleIcon.setAttribute('d', 'M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z');
                toggleButton.title = 'Hide Sidebar';
            } else {
                // Hide sidebar (arrow points right - sidebar goes to right)
                editingPanel.classList.add('hidden');
                editorArea.classList.add('sidebar-hidden');
                toggleIcon.setAttribute('d', 'M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z');
                toggleButton.title = 'Show Sidebar';
            }
        }

        let imagesHighlighted = false;

        function highlightAllImages() {
            if (!currentSiteId) {
                showToast('Please select a site first', 'error');
                return;
            }

            const iframe = document.getElementById('previewFrame');
            const button = document.getElementById('highlightImagesBtn');
            
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                const images = iframeDoc.querySelectorAll('img');
                
                if (!imagesHighlighted) {
                    // Add highlight borders to all images
                    images.forEach((img, index) => {
                        img.style.border = '3px dashed #667eea';
                        img.style.boxShadow = '0 0 10px rgba(102, 126, 234, 0.5)';
                        img.style.transition = 'all 0.3s ease';
                        
                        // Add a small number indicator
                        const indicator = iframeDoc.createElement('div');
                        indicator.style.cssText = `
                            position: absolute;
                            top: -10px;
                            left: -10px;
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            border-radius: 50%;
                            width: 24px;
                            height: 24px;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            font-size: 12px;
                            font-weight: bold;
                            z-index: 1000;
                            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                        `;
                        indicator.textContent = index + 1;
                        indicator.className = 'image-highlight-indicator';
                        
                        // Make parent relative if needed
                        const parent = img.parentElement;
                        if (getComputedStyle(parent).position === 'static') {
                            parent.style.position = 'relative';
                            parent.setAttribute('data-position-modified', 'true');
                        }
                        
                        parent.appendChild(indicator);
                    });
                    
                    showToast(`‚úÖ Found ${images.length} images in the site`, 'success');
                    button.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
                            <path d="M10.97 4.97a.235.235 0 0 0-.02.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.061L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-1.071-1.05z"/>
                        </svg>
                        Hide (${images.length})
                    `;
                    button.title = `Hide image highlights (${images.length} images found)`;
                    imagesHighlighted = true;
                    
                } else {
                    // Remove highlight borders and indicators
                    images.forEach(img => {
                        img.style.border = '';
                        img.style.boxShadow = '';
                        img.style.transition = '';
                    });
                    
                    // Remove all indicators
                    const indicators = iframeDoc.querySelectorAll('.image-highlight-indicator');
                    indicators.forEach(indicator => {
                        const parent = indicator.parentElement;
                        indicator.remove();
                        
                        // Restore original position if we modified it
                        if (parent.getAttribute('data-position-modified')) {
                            parent.style.position = '';
                            parent.removeAttribute('data-position-modified');
                        }
                    });
                    
                    button.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
                            <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>
                        </svg>
                        Highlight Images
                    `;
                    button.title = 'Highlight All Images';
                    showToast('Image highlights removed', 'info');
                    imagesHighlighted = false;
                }
                
            } catch (error) {
                console.error('Could not access iframe:', error);
                showToast('Could not access site content. Try refreshing.', 'error');
            }
        }

        // ================== Element Selection Functions ==================
        
        function toggleSelectionMode() {
            selectionMode = !selectionMode;
            const button = document.getElementById('toggleSelectionMode');
            const instructions = document.getElementById('selectionInstructions');
            const iframe = document.getElementById('previewFrame');
            
            if (selectionMode) {
                button.textContent = 'Disable Click-to-Select';
                button.classList.remove('btn-primary');
                button.classList.add('btn-secondary');
                instructions.style.display = 'block';
                
                // Enable iframe click detection
                enableIframeInteraction();
            } else {
                button.textContent = 'Enable Click-to-Select';
                button.classList.remove('btn-secondary');
                button.classList.add('btn-primary');
                instructions.style.display = 'none';
                
                // Disable iframe interaction
                disableIframeInteraction();
                clearElementSelection();
            }
        }
        
        function enableIframeInteraction() {
            const iframe = document.getElementById('previewFrame');
            
            // Function to inject selection functionality
            const injectSelectionScript = () => {
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    
                    // Remove any existing selection script
                    const existingScript = iframeDoc.getElementById('element-selection-script');
                    if (existingScript) {
                        existingScript.remove();
                    }
                    
                    // Create and inject the selection script
                    const script = iframeDoc.createElement('script');
                    script.id = 'element-selection-script';
                    script.innerHTML = `
                        // Element selection functionality
                        let selectedElement = null;
                        
                        function addSelectionStyles() {
                            const style = document.createElement('style');
                            style.id = 'selection-styles';
                            style.innerHTML = \`
                                .element-hover-selection {
                                    outline: 2px dashed #667eea !important;
                                    outline-offset: 1px !important;
                                    cursor: pointer !important;
                                }
                                .element-selected-selection {
                                    outline: 3px solid #667eea !important;
                                    outline-offset: 2px !important;
                                    background-color: rgba(102, 126, 234, 0.1) !important;
                                    position: relative !important;
                                }
                                * {
                                    cursor: crosshair !important;
                                }
                            \`;
                            document.head.appendChild(style);
                        }
                        
                        function removeSelectionStyles() {
                            const style = document.getElementById('selection-styles');
                            if (style) style.remove();
                            
                            // Remove all selection classes
                            document.querySelectorAll('.element-hover-selection, .element-selected-selection').forEach(el => {
                                el.classList.remove('element-hover-selection', 'element-selected-selection');
                            });
                            
                            // Remove image indicator
                            removeImageIndicator();
                        }
                        
                        function handleClick(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            
                            // Clear previous selection
                            if (selectedElement) {
                                selectedElement.classList.remove('element-selected-selection');
                            }
                            
                            // Advanced image detection for deeply nested structures
                            function findImageInComplexStructure(startElement) {
                                // If the clicked element is already an image, use it
                                if (startElement.tagName.toLowerCase() === 'img') {
                                    return startElement;
                                }
                                
                                // Search within the clicked element and all its descendants
                                const allImages = startElement.querySelectorAll('img');
                                if (allImages.length === 1) {
                                    // Only one image found, use it
                                    return allImages[0];
                                } else if (allImages.length > 1) {
                                    // Multiple images - find the most relevant one
                                    // Prioritize images that are not tiny (likely not icons)
                                    const significantImages = Array.from(allImages).filter(img => {
                                        const rect = img.getBoundingClientRect();
                                        return rect.width > 50 && rect.height > 50; // Filter out small icons
                                    });
                                    
                                    if (significantImages.length === 1) {
                                        return significantImages[0];
                                    } else if (significantImages.length > 1) {
                                        // Find closest to click point
                                        let closestImage = null;
                                        let minDistance = Infinity;
                                        
                                        significantImages.forEach(img => {
                                            const rect = img.getBoundingClientRect();
                                            const centerX = rect.left + rect.width / 2;
                                            const centerY = rect.top + rect.height / 2;
                                            const distance = Math.sqrt(
                                                Math.pow(e.clientX - centerX, 2) + 
                                                Math.pow(e.clientY - centerY, 2)
                                            );
                                            
                                            if (distance < minDistance) {
                                                minDistance = distance;
                                                closestImage = img;
                                            }
                                        });
                                        
                                        return closestImage;
                                    }
                                }
                                
                                return null;
                            }
                            
                            // Start with the clicked element
                            let targetElement = e.target;
                            let foundImage = findImageInComplexStructure(targetElement);
                            
                            // Only search parent elements if the clicked element doesn't have meaningful text content
                            // This prevents text selections from being hijacked by images in parent containers
                            if (!foundImage) {
                                const clickedElementText = targetElement.textContent ? targetElement.textContent.trim() : '';
                                const isTextElement = clickedElementText.length > 10; // Has substantial text content
                                const isTextTag = ['p', 'span', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'td', 'th'].includes(targetElement.tagName.toLowerCase());
                                
                                // Only search parents if:
                                // 1. The clicked element doesn't have substantial text content, AND
                                // 2. It's not a typical text-containing element, AND
                                // 3. Limit search to only 2 levels (much more conservative)
                                if (!isTextElement && (!isTextTag || clickedElementText.length < 5)) {
                                    let currentParent = targetElement.parentElement;
                                    let searchDepth = 0;
                                    
                                    while (currentParent && searchDepth < 2) { // Reduced from 5 to 2 levels
                                        // Don't search parents that have substantial text content
                                        const parentText = currentParent.textContent ? currentParent.textContent.trim() : '';
                                        const parentHasText = parentText.length > 20;
                                        
                                        if (!parentHasText) {
                                            foundImage = findImageInComplexStructure(currentParent);
                                            if (foundImage) {
                                                break;
                                            }
                                        }
                                        
                                        currentParent = currentParent.parentElement;
                                        searchDepth++;
                                    }
                                }
                            }
                            
                            // Use the found image or fall back to the original target
                            if (foundImage) {
                                targetElement = foundImage;
                                const imgSrc = foundImage.src || foundImage.getAttribute('src') || foundImage.getAttribute('data-src') || 'no src';
                                const imgAlt = foundImage.getAttribute('alt') || 'no alt';
                                const imgSrcset = foundImage.getAttribute('srcset') || 'no srcset';
                                
                                console.log('üñºÔ∏è Found image:');
                                console.log('  - src:', imgSrc);
                                console.log('  - alt:', imgAlt);
                                console.log('  - srcset:', imgSrcset.substring(0, 100) + (imgSrcset.length > 100 ? '...' : ''));
                                console.log('üìç Image element:', foundImage);
                                
                                // Generate and log the selector that will be used
                                const generatedSelector = generateSelector(foundImage);
                                console.log('üéØ Generated selector:', generatedSelector);
                            } else {
                                console.log('‚ùå No image found, using clicked element:', targetElement.tagName, targetElement.className);
                            }
                            
                            // Select new element
                            selectedElement = targetElement;
                            selectedElement.classList.add('element-selected-selection');
                            
                            // Add a unique data attribute for reliable selection
                            const elementId = 'elem_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                            targetElement.setAttribute('data-editor-element-id', elementId);
                            
                            // Send selection to parent window
                            window.parent.postMessage({
                                type: 'elementSelected',
                                elementData: {
                                    tagName: targetElement.tagName.toLowerCase(),
                                    textContent: targetElement.textContent.trim(),
                                    innerHTML: targetElement.innerHTML,
                                    style: targetElement.getAttribute('style') || '',
                                    className: targetElement.className,
                                    id: targetElement.id,
                                    elementId: elementId,
                                    selector: generateSelector(targetElement),
                                    // Add position information for precise matching
                                    position: {
                                        parentSelector: targetElement.parentElement ? generateSelector(targetElement.parentElement) : null,
                                        siblingIndex: Array.from(targetElement.parentElement?.children || []).indexOf(targetElement),
                                        textSnippet: targetElement.textContent.trim().substring(0, 50)
                                    }
                                }
                            }, '*');
                        }
                        
                        function handleMouseOver(e) {
                            if (e.target !== selectedElement) {
                                // Use the same advanced image detection for hover
                                function findImageForHover(startElement) {
                                    if (startElement.tagName.toLowerCase() === 'img') {
                                        return startElement;
                                    }
                                    
                                    const allImages = startElement.querySelectorAll('img');
                                    if (allImages.length === 1) {
                                        return allImages[0];
                                    } else if (allImages.length > 1) {
                                        // Filter out small images (likely icons)
                                        const significantImages = Array.from(allImages).filter(img => {
                                            const rect = img.getBoundingClientRect();
                                            return rect.width > 50 && rect.height > 50;
                                        });
                                        
                                        if (significantImages.length >= 1) {
                                            return significantImages[0]; // Return the first significant image
                                        }
                                    }
                                    
                                    return null;
                                }
                                
                                let hoverTarget = e.target;
                                let imageToHighlight = null;
                                
                                // Try to find an image in the hovered element
                                let foundImage = findImageForHover(hoverTarget);
                                
                                // Only search parent elements if the hovered element doesn't have meaningful text
                                if (!foundImage) {
                                    const hoveredElementText = hoverTarget.textContent ? hoverTarget.textContent.trim() : '';
                                    const isTextElement = hoveredElementText.length > 10;
                                    const isTextTag = ['p', 'span', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'td', 'th'].includes(hoverTarget.tagName.toLowerCase());
                                    
                                    // Only search parents for images if this isn't a text element
                                    if (!isTextElement && (!isTextTag || hoveredElementText.length < 5)) {
                                        let currentParent = hoverTarget.parentElement;
                                        let searchDepth = 0;
                                        
                                        while (currentParent && searchDepth < 2) { // Even more conservative for hover
                                            const parentText = currentParent.textContent ? currentParent.textContent.trim() : '';
                                            const parentHasText = parentText.length > 20;
                                            
                                            if (!parentHasText) {
                                                foundImage = findImageForHover(currentParent);
                                                if (foundImage) {
                                                    break;
                                                }
                                            }
                                            
                                            currentParent = currentParent.parentElement;
                                            searchDepth++;
                                        }
                                    }
                                }
                                
                                if (foundImage) {
                                    // Show hover effect on the image, not the container
                                    foundImage.classList.add('element-hover-selection');
                                    imageToHighlight = foundImage;
                                } else {
                                    // No image found, show hover on the original target
                                    hoverTarget.classList.add('element-hover-selection');
                                }
                                
                                // Show image indicator if we found an image
                                if (imageToHighlight) {
                                    showImageIndicator(imageToHighlight);
                                }
                            }
                        }
                        
                        function handleMouseOut(e) {
                            // Remove hover class from all elements (since we might have applied it to a different element)
                            document.querySelectorAll('.element-hover-selection').forEach(el => {
                                el.classList.remove('element-hover-selection');
                            });
                            removeImageIndicator();
                        }
                        
                        function showImageIndicator(imgElement) {
                            removeImageIndicator(); // Remove any existing indicator
                            
                            const indicator = document.createElement('div');
                            indicator.id = 'image-hover-indicator';
                            indicator.textContent = 'üñºÔ∏è Image';
                            indicator.style.cssText = \`
                                position: absolute;
                                background: #667eea;
                                color: white;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 12px;
                                font-weight: 600;
                                z-index: 10001;
                                pointer-events: none;
                                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                            \`;
                            
                            const rect = imgElement.getBoundingClientRect();
                            indicator.style.left = (rect.left + window.scrollX) + 'px';
                            indicator.style.top = (rect.top + window.scrollY - 25) + 'px';
                            
                            document.body.appendChild(indicator);
                        }
                        
                        function removeImageIndicator() {
                            const existing = document.getElementById('image-hover-indicator');
                            if (existing) existing.remove();
                        }
                        
                        function generateSelector(element) {
                            const tagName = element.tagName.toLowerCase();
                            const id = element.id;
                            let className = element.className;
                            
                            // Filter out temporary selection classes
                            if (className && typeof className === 'string') {
                                className = className
                                    .split(' ')
                                    .filter(cls => cls && cls.trim() &&
                                           cls !== 'element-hover-selection' && 
                                           cls !== 'element-selected-selection')
                                    .join(' ');
                            }
                            
                            // Validate ID before using it as a CSS selector
                            if (id && /^[a-zA-Z][a-zA-Z0-9_-]*$/.test(id)) {
                                return '#' + id;
                            }
                            
                            // For images, create a highly specific selector using src attribute
                            if (tagName === 'img') {
                                const src = element.getAttribute('src') || element.getAttribute('data-src');
                                const srcset = element.getAttribute('srcset');
                                const alt = element.getAttribute('alt');
                                
                                // Try to use src attribute for uniqueness
                                if (src) {
                                    // Extract a unique part from the src
                                    const srcParts = src.split('/');
                                    const filename = srcParts[srcParts.length - 1];
                                    const filenameWithoutQuery = filename.split('?')[0];
                                    const filenameWithoutExt = filenameWithoutQuery.split('.')[0];
                                    
                                    if (filenameWithoutExt && filenameWithoutExt.length > 3) {
                                        return 'img[src*="' + filenameWithoutExt + '"]';
                                    }
                                }
                                
                                // Try to use alt attribute if src is not unique enough
                                if (alt && alt.trim() && alt.length > 0) {
                                    return 'img[alt="' + alt.trim() + '"]';
                                }
                                
                                // Try to use srcset if available
                                if (srcset) {
                                    const firstSrcInSet = srcset.split(',')[0].trim().split(' ')[0];
                                    if (firstSrcInSet) {
                                        const srcParts = firstSrcInSet.split('/');
                                        const filename = srcParts[srcParts.length - 1];
                                        const filenameWithoutQuery = filename.split('?')[0];
                                        const filenameWithoutExt = filenameWithoutQuery.split('.')[0];
                                        
                                        if (filenameWithoutExt && filenameWithoutExt.length > 3) {
                                            return 'img[srcset*="' + filenameWithoutExt + '"]';
                                        }
                                    }
                                }
                            }
                            
                            // Generate hierarchical selector for better specificity
                            const parent = element.parentElement;
                            if (parent) {
                                const siblings = Array.from(parent.children);
                                const sameTagSiblings = siblings.filter(sibling => sibling.tagName.toLowerCase() === tagName);
                                const index = sameTagSiblings.indexOf(element) + 1;
                                
                                // Create more specific selector with parent context
                                let parentSelector = '';
                                
                                // Try to build a unique parent path
                                let currentParent = parent;
                                let parentPath = [];
                                let depth = 0;
                                
                                while (currentParent && depth < 3) {
                                    const parentTag = currentParent.tagName.toLowerCase();
                                    const parentId = currentParent.id;
                                    const parentClass = currentParent.className;
                                    
                                    if (parentId && /^[a-zA-Z][a-zA-Z0-9_-]*$/.test(parentId)) {
                                        parentPath.unshift('#' + parentId);
                                        break; // ID is unique enough, stop here
                                    } else if (parentClass && typeof parentClass === 'string') {
                                        const cleanParentClass = parentClass
                                            .split(' ')
                                            .filter(cls => cls && cls.trim() && !cls.includes('elementor') && !cls.includes('wp-'))
                                            .slice(0, 1) // Use only first class
                                            .join('.');
                                        if (cleanParentClass) {
                                            parentPath.unshift(parentTag + '.' + cleanParentClass);
                                        } else {
                                            parentPath.unshift(parentTag);
                                        }
                                    } else {
                                        parentPath.unshift(parentTag);
                                    }
                                    
                                    currentParent = currentParent.parentElement;
                                    depth++;
                                }
                                
                                parentSelector = parentPath.join(' > ');
                                
                                // Use nth-of-type for better targeting when there are multiple siblings
                                if (sameTagSiblings.length > 1) {
                                    return parentSelector + ' > ' + tagName + ':nth-of-type(' + index + ')';
                                } else {
                                    return parentSelector + ' > ' + tagName;
                                }
                            }
                            
                            // Fallback to class-based selector
                            if (className && className.trim()) {
                                const cleanClassName = className.trim().split(' ').join('.');
                                return tagName + '.' + cleanClassName;
                            }
                            
                            return tagName;
                        }
                        
                        // Initialize selection mode
                        addSelectionStyles();
                        document.addEventListener('click', handleClick, true);
                        document.addEventListener('mouseover', handleMouseOver);
                        document.addEventListener('mouseout', handleMouseOut);
                        
                        // Disable all links and forms
                        document.querySelectorAll('a, form, button, input[type="submit"]').forEach(el => {
                            el.addEventListener('click', (e) => {
                                e.preventDefault();
                                e.stopPropagation();
                            }, true);
                        });
                    `;
                    
                    iframeDoc.body.appendChild(script);
                    showToast('Element selection enabled! Click any element to select it.');
                    
                } catch (error) {
                    console.log('Failed to inject selection script:', error);
                    showToast('Unable to enable element selection. Try refreshing the preview.', 'error');
                }
            };
            
            // Set up iframe load handler
            iframe.onload = injectSelectionScript;
            
            // If iframe is already loaded, inject immediately
            if (iframe.src && iframe.src !== 'about:blank') {
                setTimeout(injectSelectionScript, 100);
            }
        }
        
        function disableIframeInteraction() {
            const iframe = document.getElementById('previewFrame');
            
            const removeSelectionScript = () => {
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                    
                    // Remove selection script and styles
                    const script = iframeDoc.getElementById('element-selection-script');
                    const styles = iframeDoc.getElementById('selection-styles');
                    
                    if (script) script.remove();
                    if (styles) styles.remove();
                    
                    // Remove all selection classes
                    iframeDoc.querySelectorAll('.element-hover-selection, .element-selected-selection').forEach(el => {
                        el.classList.remove('element-hover-selection', 'element-selected-selection');
                    });
                    
                } catch (error) {
                    // Ignore cross-origin errors
                }
            };
            
            iframe.onload = removeSelectionScript;
            
            // Remove immediately if iframe is already loaded
            if (iframe.src && iframe.src !== 'about:blank') {
                setTimeout(removeSelectionScript, 100);
            }
        }
        
        // Listen for messages from iframe
        window.addEventListener('message', (event) => {
            if (event.data.type === 'elementSelected') {
                handleElementSelection(event.data.elementData);
            }
        });
        
        function handleElementSelection(elementData) {
            if (!selectionMode) return;
            
            // Store the selected element data
            selectedElement = elementData;
            elementSelector = elementData.selector;
            
            // Show editor interface
            showElementEditor(elementData);
            
            showToast('Element selected! Edit it in the panel on the right.');
        }
        
        function clearElementSelection() {
            selectedElement = null;
            elementSelector = null;
            
            // Hide editor interface
            document.getElementById('selectedElementEditor').style.display = 'none';
            
            // Clear selection in iframe
            const iframe = document.getElementById('previewFrame');
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                iframeDoc.querySelectorAll('.element-selected-selection').forEach(el => {
                    el.classList.remove('element-selected-selection');
                });
            } catch (error) {
                // Ignore cross-origin errors
            }
        }
        
        function showElementEditor(elementData) {
            const editor = document.getElementById('selectedElementEditor');
            
            editor.style.display = 'block';
            
            // Populate element info
            document.getElementById('elementTag').textContent = elementData.tagName;
            document.getElementById('elementSelector').textContent = elementData.selector;
            document.getElementById('elementContent').textContent = elementData.textContent.substring(0, 100) + (elementData.textContent.length > 100 ? '...' : '');
            
            // Check if this is an image element
            const isImage = elementData.tagName.toLowerCase() === 'img';
            
            // Check if element has text content (trim to remove whitespace)
            const hasTextContent = elementData.textContent && elementData.textContent.trim().length > 0;
            
            // Show/hide appropriate controls based on element type
            const imageControls = document.getElementById('imageControls');
            const textContentEditor = document.getElementById('textContentEditor');
            const colorControls = document.getElementById('colorControls');
            
            if (isImage) {
                // Show image controls, hide text editors
                imageControls.style.display = 'block';
                textContentEditor.style.display = 'none';
                
                // Hide color controls for images
                colorControls.style.display = 'none';
                
                // Update element content to show image info - extract from actual element attributes
                let imgSrc = 'No source';
                let imgAlt = 'No alt text';
                
                // Try to extract src from various possible attributes
                const srcMatch = elementData.innerHTML.match(/src="([^"]*)"/) || elementData.innerHTML.match(/data-src="([^"]*)"/) || ['', ''];
                if (srcMatch[1]) {
                    imgSrc = srcMatch[1];
                } else {
                    // Try srcset if src is not available
                    const srcsetMatch = elementData.innerHTML.match(/srcset="([^"]*)"/) || ['', ''];
                    if (srcsetMatch[1]) {
                        // Extract first URL from srcset
                        const firstSrc = srcsetMatch[1].split(',')[0].trim().split(' ')[0];
                        if (firstSrc) {
                            imgSrc = firstSrc;
                        }
                    }
                }
                
                // Extract alt attribute
                const altMatch = elementData.innerHTML.match(/alt="([^"]*)"/) || ['', ''];
                if (altMatch[1]) {
                    imgAlt = altMatch[1];
                }
                
                // Show filename instead of full URL for better readability
                const displaySrc = imgSrc !== 'No source' ? imgSrc.split('/').pop().split('?')[0] : imgSrc;
                
                document.getElementById('elementContent').textContent = `Source: ${displaySrc} | Alt: ${imgAlt}`;
            } else {
                // Show regular controls, hide image controls
                imageControls.style.display = 'none';
                textContentEditor.style.display = 'block';
                
                // Only show Quick Colors section if element has text content
                colorControls.style.display = hasTextContent ? 'block' : 'none';
            }
            
            // Populate editors
            document.getElementById('elementTextEditor').value = elementData.textContent;
            
            // Extract colors from style attribute if available
            const style = elementData.style || '';
            const colorMatch = style.match(/color\s*:\s*([^;]+)/);
            const bgColorMatch = style.match(/background-color\s*:\s*([^;]+)/);
            
            if (colorMatch) {
                const normalizedColor = normalizeColor(colorMatch[1].trim());
                if (normalizedColor !== '#000000') {
                    document.getElementById('textColorPicker').value = normalizedColor;
                }
            }
            
            if (bgColorMatch) {
                const normalizedBgColor = normalizeColor(bgColorMatch[1].trim());
                if (normalizedBgColor !== '#ffffff') {
                    document.getElementById('bgColorPicker').value = normalizedBgColor;
                }
            }
        }
        
        function generateElementSelector(element) {
            // Generate a unique selector for the element (consistent with iframe version)
            const tagName = element.tagName.toLowerCase();
            const id = element.id;
            
            if (id) return `#${id}`;
            
            // Skip class-based selectors for complex utility classes - they cause issues
            // Always use nth-child for more reliable targeting
            
            // Generate nth-child selector
            const parent = element.parentElement;
            if (parent) {
                const siblings = Array.from(parent.children);
                const index = siblings.indexOf(element) + 1;
                return `${tagName}:nth-child(${index})`;
            }
            
            return tagName;
        }
        
        // ================== Element Update Functions ==================
        
        async function updateSelectedElementText() {
            if (!selectedElement || !currentSiteId || !elementSelector) return;
            
            const newText = document.getElementById('elementTextEditor').value;
            
            try {
                const response = await fetch(`/api/sites/${currentSiteId}/element`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selector: elementSelector,
                        elementId: selectedElement.elementId,
                        action: 'updateText',
                        value: newText,
                        position: selectedElement.position
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Update the selected element data
                    selectedElement.textContent = newText;
                    
                    // Update the element in iframe
                    updateElementInIframe(elementSelector, 'textContent', newText);
                    
                    showToast('Text updated successfully!');
                    
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('Failed to update text: ' + error.message, 'error');
            }
        }
        
        function updateElementInIframe(selector, property, value) {
            const iframe = document.getElementById('previewFrame');
            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                const element = iframeDoc.querySelector(selector);
                if (element) {
                    if (property === 'textContent') {
                        element.textContent = value;
                    } else if (property === 'innerHTML') {
                        element.innerHTML = value;
                    } else if (property === 'style') {
                        element.setAttribute('style', value);
                    }
                }
            } catch (error) {
                console.log('Could not update element in iframe:', error);
            }
        }
        
        
        async function applyTextColor() {
            if (!selectedElement || !currentSiteId || !elementSelector) return;
            
            const color = document.getElementById('textColorPicker').value;
            const currentStyle = selectedElement.style || '';
            const newStyle = currentStyle.replace(/color\s*:[^;]*;?/g, '') + `color: ${color};`;
            
            try {
                const response = await fetch(`/api/sites/${currentSiteId}/element`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selector: elementSelector,
                        elementId: selectedElement.elementId,
                        action: 'updateCss',
                        value: newStyle,
                        position: selectedElement.position
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    selectedElement.style = newStyle;
                    updateElementInIframe(elementSelector, 'style', newStyle);
                    showToast('Text color applied!');
                    
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('Failed to apply text color: ' + error.message, 'error');
            }
        }
        
        async function applyBgColor() {
            if (!selectedElement || !currentSiteId || !elementSelector) return;
            
            const color = document.getElementById('bgColorPicker').value;
            const currentStyle = selectedElement.style || '';
            const newStyle = currentStyle.replace(/background-color\s*:[^;]*;?/g, '') + `background-color: ${color};`;
            
            try {
                const response = await fetch(`/api/sites/${currentSiteId}/element`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selector: elementSelector,
                        elementId: selectedElement.elementId,
                        action: 'updateCss',
                        value: newStyle,
                        position: selectedElement.position
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    selectedElement.style = newStyle;
                    updateElementInIframe(elementSelector, 'style', newStyle);
                    showToast('Background color applied!');
                    
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('Failed to apply background color: ' + error.message, 'error');
            }
        }
        
        // ================== Font Functions ==================
        
        async function applyWebsiteFont() {
            if (!currentSiteId) return;
            
            const fontFamily = document.getElementById('fontSelector').value;
            if (!fontFamily) {
                showToast('Please select a font first', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/api/sites/${currentSiteId}/font`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ fontFamily })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Apply font to iframe body immediately
                    const iframe = document.getElementById('previewFrame');
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        iframeDoc.body.style.fontFamily = fontFamily;
                    } catch (error) {
                        console.log('Could not update font in iframe:', error);
                    }
                    
                    showToast('Font applied successfully!');
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('Failed to apply font: ' + error.message, 'error');
            }
        }
        
        // ================== Image Functions ==================
        
        async function deleteSelectedImage() {
            if (!selectedElement || !currentSiteId || !elementSelector) return;
            
            if (!confirm('Are you sure you want to delete this image? This action cannot be undone.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/sites/${currentSiteId}/element`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        selector: elementSelector,
                        elementId: selectedElement.elementId,
                        action: 'delete',
                        position: selectedElement.position
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    // Remove element from iframe
                    const iframe = document.getElementById('previewFrame');
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        const element = iframeDoc.querySelector(`[data-editor-element-id="${selectedElement.elementId}"]`);
                        if (element) {
                            element.remove();
                        }
                    } catch (error) {
                        console.log('Could not remove element from iframe:', error);
                    }
                    
                    showToast('Image deleted successfully!');
                    clearElementSelection();
                    
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('Failed to delete image: ' + error.message, 'error');
            }
        }
        
        async function replaceSelectedImage(event) {
            if (!selectedElement || !currentSiteId || !elementSelector) return;
            
            const file = event.target.files[0];
            if (!file) return;
            
            // Validate file type
            if (!file.type.startsWith('image/')) {
                showToast('Please select a valid image file', 'error');
                return;
            }
            
            // Check file size (limit to 5MB)
            if (file.size > 5 * 1024 * 1024) {
                showToast('Image file is too large. Please select a file under 5MB.', 'error');
                return;
            }
            
            try {
                // Create FormData for file upload
                const formData = new FormData();
                formData.append('image', file);
                formData.append('selector', elementSelector);
                formData.append('elementId', selectedElement.elementId);
                formData.append('position', JSON.stringify(selectedElement.position));
                
                showToast('Uploading image...', 'success');
                
                const response = await fetch(`/api/sites/${currentSiteId}/image/replace`, {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                if (result.success) {
                    // Update element in iframe
                    const iframe = document.getElementById('previewFrame');
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        const element = iframeDoc.querySelector(`[data-editor-element-id="${selectedElement.elementId}"]`);
                        if (element && element.tagName.toLowerCase() === 'img') {
                            element.src = result.imagePath;
                        }
                    } catch (error) {
                        console.log('Could not update element in iframe:', error);
                    }
                    
                    // Update selected element data
                    selectedElement.innerHTML = selectedElement.innerHTML.replace(/src="[^"]*"/, `src="${result.imagePath}"`);
                    
                    // Update the element info display
                    const imgAlt = selectedElement.innerHTML.match(/alt="([^"]*)"/) || ['', 'No alt text'];
                    document.getElementById('elementContent').textContent = `Source: ${result.imagePath} | Alt: ${imgAlt[1]}`;
                    
                    showToast('Image replaced successfully!');
                    
                } else {
                    throw new Error(result.error);
                }
            } catch (error) {
                showToast('Failed to replace image: ' + error.message, 'error');
            }
            
            // Clear the file input
            event.target.value = '';
        }
        
        // ================== Utility Functions ==================
        
        function rgbToHex(rgb) {
            if (!rgb || rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') return '#ffffff';
            
            const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
            if (match) {
                const r = parseInt(match[1]).toString(16).padStart(2, '0');
                const g = parseInt(match[2]).toString(16).padStart(2, '0');
                const b = parseInt(match[3]).toString(16).padStart(2, '0');
                return `#${r}${g}${b}`;
            }
            
            return rgb.startsWith('#') ? rgb : '#000000';
        }
        
        function normalizeColor(color) {
            // Convert color values to hex format for color input
            if (color.startsWith('#')) return color;
            if (color.startsWith('rgb')) {
                const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (match) {
                    const r = parseInt(match[1]).toString(16).padStart(2, '0');
                    const g = parseInt(match[2]).toString(16).padStart(2, '0');
                    const b = parseInt(match[3]).toString(16).padStart(2, '0');
                    return `#${r}${g}${b}`;
                }
            }
            return '#000000'; // Default fallback
        }

        async function loadSites() {
            try {
                const response = await fetch('/api/sites');
                const sites = await response.json();
                
                const siteList = document.getElementById('siteList');
                
                if (sites.length === 0) {
                    siteList.innerHTML = '<li class="loading">No cloned sites found</li>';
                    return;
                }
                
                siteList.innerHTML = sites.map(site => `
                    <li class="site-item" data-site-id="${site.siteId}">
                        <div class="site-title">${site.siteName || new URL(site.originalUrl).hostname}</div>
                        <div class="site-url">${site.originalUrl}</div>
                        <div class="site-url">Cloned: ${new Date(site.clonedAt).toLocaleDateString()}</div>
                        ${site.lastEdited ? `<div class="site-url">Edited: ${new Date(site.lastEdited).toLocaleDateString()}</div>` : ''}
                        <div class="site-actions">
                            <button class="delete-btn" data-site-id="${site.siteId}" data-site-name="${site.siteName || new URL(site.originalUrl).hostname}">
                                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                    <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                    <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                </svg>
                            </button>
                        </div>
                    </li>
                `).join('');
                
                // Add click listeners
                siteList.querySelectorAll('.site-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // Don't trigger site selection when clicking the delete button
                        if (e.target.closest('.delete-btn')) {
                            e.stopPropagation();
                            return;
                        }
                        selectSite(item.dataset.siteId);
                    });
                });
                
                // Add delete button click listeners
                siteList.querySelectorAll('.delete-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showDeleteModal(button.dataset.siteId, button.dataset.siteName);
                    });
                });

                // Auto-select previously selected site
                const savedSiteId = localStorage.getItem('selectedSiteId');
                if (savedSiteId) {
                    const savedSiteElement = document.querySelector(`[data-site-id="${savedSiteId}"]`);
                    if (savedSiteElement) {
                        setTimeout(() => selectSite(savedSiteId), 100);
                    } else {
                        // Clear invalid saved site ID
                        localStorage.removeItem('selectedSiteId');
                    }
                }
                
            } catch (error) {
                showToast('Failed to load sites', 'error');
                console.error('Error loading sites:', error);
            }
        }

        async function selectSite(siteId) {
            if (currentSiteId === siteId) return;
            
            // Clear previous selection
            document.querySelectorAll('.site-item').forEach(item => item.classList.remove('active'));
            document.querySelector(`[data-site-id="${siteId}"]`).classList.add('active');
            
            currentSiteId = siteId;
            
            // Save selected site to localStorage
            localStorage.setItem('selectedSiteId', siteId);
            
            // Preview button has been commented out
            // document.getElementById('previewBtn').disabled = false;
            document.getElementById('deployBtn').disabled = false;
            
            // Load site preview with loading indicator
            const previewFrame = document.getElementById('previewFrame');
            const previewLoading = document.getElementById('previewLoading');
            
            previewLoading.style.display = 'block';
            previewFrame.style.opacity = '0.5';
            
            previewFrame.onload = () => {
                previewLoading.style.display = 'none';
                previewFrame.style.opacity = '1';
            };
            
            previewFrame.src = `/preview/${siteId}`;
            
            // Show editing content
            document.getElementById('noSiteSelected').style.display = 'none';
            document.getElementById('editingContent').style.display = 'block';
            
            // Wait for DOM to update before loading content
            setTimeout(async () => {
                await loadSiteContent(siteId);
            }, 50);
        }

        async function loadSiteContent(siteId) {
            try {
                if (!siteId) {
                    console.warn('loadSiteContent called without siteId');
                    return;
                }
                
                const response = await fetch(`/api/sites/${siteId}/content`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch site content: ${response.status} ${response.statusText}`);
                }
                
                const content = await response.json();
                
                if (!content || !content.textElements) {
                    throw new Error('Invalid content structure received from server');
                }
                
                // Content loading removed - only selected element editing is now available
                
                // Restore font selector after loading content
                setTimeout(() => {
                    const iframe = document.getElementById('previewFrame');
                    try {
                        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        const fontStyle = iframeDoc.getElementById('website-font-style');
                        if (fontStyle) {
                            const match = fontStyle.textContent.match(/font-family:\s*([^;!]+)/);
                            if (match) {
                                const font = match[1].trim();
                                const selector = document.getElementById('fontSelector');
                                for (let i = 0; i < selector.options.length; i++) {
                                    if (selector.options[i].value === font) {
                                        selector.selectedIndex = i;
                                        break;
                                    }
                                }
                            }
                        }
                    } catch (e) {}
                }, 500);
                
            } catch (error) {
                console.error('Error loading site content:', error);
                
                if (error.message.includes('404')) {
                    showToast('Site not found. It may have been deleted.', 'error');
                } else if (error.message.includes('Failed to fetch')) {
                    showToast('Network error. Please check your connection.', 'error');
                } else {
                    showToast(`Failed to load site content: ${error.message}`, 'error');
                }
                
                // Content loading error - only selected element editing is available
            }
        }

        function openPreview() {
            if (currentSiteId) {
                window.open(`/preview/${currentSiteId}`, '_blank');
            }
        }

        function normalizeColor(color) {
            // Convert color values to hex format for color input
            if (color.startsWith('#')) return color;
            if (color.startsWith('rgb')) {
                const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (match) {
                    const r = parseInt(match[1]).toString(16).padStart(2, '0');
                    const g = parseInt(match[2]).toString(16).padStart(2, '0');
                    const b = parseInt(match[3]).toString(16).padStart(2, '0');
                    return `#${r}${g}${b}`;
                }
            }
            return '#000000'; // Default fallback
        }

        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        
        // Delete site functionality
        let siteToDelete = null;
        
        function showDeleteModal(siteId, siteName) {
            siteToDelete = siteId;
            document.getElementById('deleteSiteName').textContent = siteName;
            document.getElementById('deleteModal').classList.add('show');
        }
        
        function hideDeleteModal() {
            document.getElementById('deleteModal').classList.remove('show');
            siteToDelete = null;
        }
        
        async function confirmDeleteSite() {
            if (!siteToDelete) return;
            
            try {
                const response = await fetch(`/api/sites/${siteToDelete}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // If the deleted site was the current site, reset the UI
                    if (siteToDelete === currentSiteId) {
                        currentSiteId = null;
                        localStorage.removeItem('selectedSiteId');
                        document.getElementById('previewFrame').src = 'about:blank';
                        document.getElementById('noSiteSelected').style.display = 'block';
                        document.getElementById('editingContent').style.display = 'none';
                        document.getElementById('deployBtn').disabled = true;
                    } else if (siteToDelete === localStorage.getItem('selectedSiteId')) {
                        // Clear localStorage if the deleted site was the saved one
                        localStorage.removeItem('selectedSiteId');
                    }
                    
                    // Reload the sites list
                    await loadSites();
                    showToast('Site deleted successfully');
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                showToast(`Failed to delete site: ${error.message}`, 'error');
                console.error('Delete error:', error);
            } finally {
                hideDeleteModal();
            }
        }
    </script>
</body>
</html>
